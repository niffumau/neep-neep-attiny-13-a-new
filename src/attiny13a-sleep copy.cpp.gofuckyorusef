/*
 *
 * 
 * https://github.com/pedroliska/ATtiny85/blob/master/watchdog-wake/watchdog-wake.ino
 * 
 * 
 * 
 * 
 */



#include <Arduino.h>
#include <avr/io.h>
#include <util/delay.h>

#include <avr/interrupt.h>
#include <avr/pgmspace.h>

#include <avr/interrupt.h>

#include <avr/power.h>
#include <avr/sleep.h>
//#include <avr/wdt.h>

#ifndef ARDUINO
#include <stdint.h>
#include "millionUtil.h"         //not needed if compiled with Arduino & Arduino-Tiny
#endif



#ifdef __AVR_ATtiny13__
  #define SLEEP_FOREVER  128
  #define SLEEP_016MS    ~(1<<WDP3)|~(1<<WDP2)|~(1<<WDP1)|~(1<<WDP0)
  #define SLEEP_125MS    (1<<WDP1) | (1<<WDP0)
  #define SLEEP_250MS    (1<<WDP2)
  #define SLEEP_500MS    (1<<WDP2) | (1<<WDP0)
  #define SLEEP_1SEC     (1<<WDP2) | (1<<WDP1)
  #define SLEEP_2SEC     (1<<WDP2) | (1<<WDP1) | (1<<WDP0)
  #define SLEEP_4SEC     (1<<WDP3)
  #define SLEEP_8SEC     (1<<WDP3) | (1<<WDP0)
#endif /* ifdef __AVR_ATtiny13__ */


/*
#define BODS 7                   //BOD Sleep bit in MCUCR
#define BODSE 2                  //BOD Sleep enable bit in MCUCR
*/


#define	BUZZER_PIN	PB1

#define IS_BUZZER			// Define if its a buzzer

//#define LED_PIN 	PB4                     // PB0 as a LED pin
//#define LED_PIN2 	PB0            

#define LED_RED  	PB4
#define LED_GREEN	PB0 

uint8_t mcucr1, mcucr2;

int REGULAR_HI_MS = 100;        // was 800
int WAKE_INDICATOR_HI_MS = 0; //200;
int INITIAL_BEEP_COUNT = 3;   // number of "test" beeps before we go into the real loop

// RANDOM_SLEEP_MIN = minimum number of 8-sec WDT periods to sleep for
// RANDOM_SLEEP_MAX = maximum number of 8-sec WDT periods to sleep for
//int RANDOM_SLEEP_MIN = 7;     // 1 min (1 * 60 / 8)
//int RANDOM_SLEEP_MAX = 30;    // 4 mins
//int RANDOM_SLEEP_MIN = 225; // 30 mins
//int RANDOM_SLEEP_MAX = 525; // 70 mins

#define SLEEP_FACTOR 8								// what we count intervals in


uint16_t RANDOM_SLEEP_MIN = 1;			/// was 7
uint16_t RANDOM_SLEEP_MAX = 200;		// 2 is very regular, was 30



//uint8_t mcucr1, mcucr2;



#define	N_1	(_BV(CS00))
#define	N_8	(_BV(CS01))
#define	N_64	(_BV(CS01)|_BV(CS00))
#define	N_256	(_BV(CS02))
#define	N_1024	(_BV(CS02)|_BV(CS00))

typedef struct s_note {
	uint8_t OCRxn; // 0..255
	uint8_t N;
} note_t;

typedef struct s_octave {
	note_t note_C;
	note_t note_CS;
	note_t note_D;
	note_t note_DS;
	note_t note_E;
	note_t note_F;
	note_t note_FS;
	note_t note_G;
	note_t note_GS;
	note_t note_A;
	note_t note_AS;
	note_t note_B;
} octave_t;


PROGMEM const octave_t octaves[8] = {
	{ // octave 0
	.note_C = {142, N_256}, // 16.35 Hz
	.note_CS = {134, N_256}, // 17.32 Hz
	.note_D = {127, N_256}, // 18.35 Hz
	.note_DS = {120, N_256}, // 19.45 Hz
	.note_E = {113, N_256}, // 20.60 Hz
	.note_F = {106, N_256}, // 21.83 Hz
	.note_FS = {100, N_256}, // 23.12 Hz
	.note_G = {95, N_256}, // 24.50 Hz
	.note_GS = {89, N_256}, // 25.96 Hz
	.note_A = {84, N_256}, // 27.50 Hz
	.note_AS = {79, N_256}, // 29.14 Hz
	.note_B = {75, N_256} // 30.87 Hz
	},
	{ // octave 1
	.note_C = {71, N_256}, // 32.70 Hz
	.note_CS = {67, N_256}, // 34.65 Hz
	.note_D = {63, N_256}, // 36.71 Hz
	.note_DS = {59, N_256}, // 38.89 Hz
	.note_E = {56, N_256}, // 41.20 Hz
	.note_F = {53, N_256}, // 43.65 Hz
	.note_FS = {50, N_256}, // 46.25 Hz
	.note_G = {47, N_256}, // 49.00 Hz
	.note_GS = {44, N_256}, // 51.91 Hz
	.note_A = {42, N_256}, // 55.00 Hz
	.note_AS = {39, N_256}, // 58.27 Hz
	.note_B = {37, N_256} // 61.74 Hz
	},
	{ // octave 2
	.note_C = {142, N_64}, // 65.41 Hz
	.note_CS = {134, N_64}, // 69.30 Hz
	.note_D = {127, N_64}, // 73.42 Hz
	.note_DS = {120, N_64}, // 77.78 Hz
	.note_E = {113, N_64}, // 82.41 Hz
	.note_F = {106, N_64}, // 87.31 Hz
	.note_FS = {100, N_64}, // 92.50 Hz
	.note_G = {95, N_64}, // 98.00 Hz
	.note_GS = {89, N_64}, // 103.83 Hz
	.note_A = {84, N_64}, // 110.00 Hz
	.note_AS = {79, N_64}, // 116.54 Hz
	.note_B = {75, N_64} // 123.47 Hz
	},
	{ // octave 3
	.note_C = {71, N_64}, // 130.81 Hz
	.note_CS = {67, N_64}, // 138.59 Hz
	.note_D = {63, N_64}, // 146.83 Hz
	.note_DS = {59, N_64}, // 155.56 Hz
	.note_E = {56, N_64}, // 164.81 Hz
	.note_F = {53, N_64}, // 174.61 Hz
	.note_FS = {50, N_64}, // 185.00 Hz
	.note_G = {47, N_64}, // 196.00 Hz
	.note_GS = {44, N_64}, // 207.65 Hz
	.note_A = {42, N_64}, // 220.00 Hz
	.note_AS = {39, N_64}, // 233.08 Hz
	.note_B = {37, N_64} // 246.94 Hz
	},
	{ // octave 4
	.note_C = {35, N_64}, // 261.63 Hz
	.note_CS = {33, N_64}, // 277.18 Hz
	.note_D = {31, N_64}, // 293.66 Hz
	.note_DS = {29, N_64}, // 311.13 Hz
	.note_E = {27, N_64}, // 329.63 Hz
	.note_F = {26, N_64}, // 349.23 Hz
	.note_FS = {24, N_64}, // 369.99 Hz
	.note_G = {23, N_64}, // 392.00 Hz
	.note_GS = {22, N_64}, // 415.30 Hz
	.note_A = {20, N_64}, // 440.00 Hz
	.note_AS = {19, N_64}, // 466.16 Hz
	.note_B = {18, N_64} // 493.88 Hz
	},
	{  // octave 5
	.note_C = {142, N_8}, // 523.25 Hz
	.note_CS = {134, N_8}, // 554.37 Hz
	.note_D = {127, N_8}, // 587.33 Hz
	.note_DS = {120, N_8}, // 622.25 Hz
	.note_E = {113, N_8}, // 659.25 Hz
	.note_F = {106, N_8}, // 349.23 Hz
	.note_FS = {100, N_8}, // 369.99 Hz
	.note_G = {95, N_8}, // 392.00 Hz
	.note_GS = {89, N_8}, // 415.30 Hz
	.note_A = {84, N_8}, // 440.00 Hz
	.note_AS = {79, N_8}, // 466.16 Hz
	.note_B = {75, N_8} // 493.88 Hz
	},
	{  // octave 6
	.note_C = {71, N_8}, // 1046.50 Hz
	.note_CS = {67, N_8}, // 1108.73 Hz
	.note_D = {63, N_8}, // 1174.66 Hz
	.note_DS = {59, N_8}, // 1244.51 Hz
	.note_E = {56, N_8}, // 1318.51 Hz
	.note_F = {53, N_8}, // 1396.91 Hz
	.note_FS = {50, N_8}, // 1479.98 Hz
	.note_G = {47, N_8}, // 1567.98 Hz
	.note_GS = {44, N_8}, // 1661.22 Hz
	.note_A = {42, N_8}, // 1760.00 Hz
	.note_AS = {39, N_8}, // 1864.66 Hz
	.note_B = {37, N_8} // 1975.53 Hz
	},
	{  // octave 7
	.note_C = {35, N_8}, // 2093.00 Hz
	.note_CS = {33, N_8}, // 2217.46 Hz
	.note_D = {31, N_8}, // 2349.32 Hz
	.note_DS = {29, N_8}, // 2489.02 Hz
	.note_E = {27, N_8}, // 2637.02 Hz
	.note_F = {26, N_8}, // 2793.83 Hz
	.note_FS = {24, N_8}, // 2959.96 Hz
	.note_G = {23, N_8}, // 3135.96 Hz
	.note_GS = {22, N_8}, // 3322.44 Hz
	.note_A = {20, N_8}, // 3520.00 Hz
	.note_AS = {19, N_8}, // 3729.31 Hz
	.note_B = {18, N_8} // 3951.07 Hz
	}
};



/*******************************************************************************************************************************
 *  LED Functions
 *******************************************************************************************************************************/

/***************************************************
 *  led_setup
 ***************************************************
 * 
 */
void led_setup(void){
  pinMode(LED_RED, OUTPUT);
  pinMode(LED_GREEN, OUTPUT);
  //DDRB |= (1 << LED_PIN);	// set as output
  //DDRB |= (1 << LED_PIN2);	// set as output
  PORTB = 0b00000000;	// Set all of port b to 0
  //digitalWrite(LED_PIN, LOW); 
  //digitalWrite(LED_PIN2, LOW); 

}
/***************************************************
 *  led_toggle
 ***************************************************
 * 
 */
void led_toggle(uint8_t _PIN){
  //PORTB ^= _BV(LED_PIN2);  // toggle LED pin		//_BV returns the byte value of some shit
  PORTB ^= _BV(_PIN);  // toggle LED pin		//_BV returns the byte value of some shit
  //digitalWrite(LED_PIN2, HIGH); 

}
/***************************************************
 *  led_on
 ***************************************************
 * 
 */
void led_on(int _PIN){
	digitalWrite(_PIN, HIGH); 
	//DDRB |= (1 << _PIN);		// these result in the same shit

}
#define BLINK_INTERVAL_ON 			300		//ms
#define BLINK_INTERVAL_OFF 			100		//ms
#define BLINK_INTERVAL_END 			500		//ms
#define BLINK_INTERVAL_STATUS_END	500		//ms
/***************************************************
 *  led_off
 ***************************************************
 * 
 */
void led_off(int _PIN){
  	digitalWrite(_PIN, LOW); 
	//DDRB &= ~(0 << _PIN);
}
void led_blink(int _PIN,int _number) {
	for (uint8_t i=0;i < _number;i++ ){ 
		//PORTB ^= _BV(_PIN);
		digitalWrite(_PIN, HIGH);
		_delay_ms(BLINK_INTERVAL_ON);
		digitalWrite(_PIN, LOW);
		_delay_ms(BLINK_INTERVAL_OFF);
	}
	_delay_ms(BLINK_INTERVAL_END);
}

void led_status(int _first,int _second) {
	led_blink(LED_RED,_first);
	led_blink(LED_GREEN,_second);
	_delay_ms(BLINK_INTERVAL_STATUS_END);
}

/***************************************************
 *  Play Tones
 ***************************************************
 * 
 */
void _playtones(void){
//	led_status(4,1);

#ifdef IS_BUZZER	
	pinMode(BUZZER_PIN, OUTPUT);
	led_on(BUZZER_PIN);
	_delay_ms(200);
	led_off(BUZZER_PIN);
#else
	_setuptone();
	_tone(4, 7);	//note_C 
	_delay_ms(100);
	_tone(3, 6);	//
	_delay_ms(100);
	_tone(3, 3);	//
	_delay_ms(100);
	stop();
#endif
	//led_off(LED_RED);
}

/***************************************************
 * check_random 
 ***************************************************
 * Check that the random number is between our limits
 */
void check_random(uint16_t _return) {

	if (_return < RANDOM_SLEEP_MIN) {
		led_blink(LED_RED,4);
	}
	if (_return > RANDOM_SLEEP_MAX + 2){
		led_blink(LED_GREEN,4);
	}
}
/*******************************************************************************************************************************
 *  Tone Functions
 *******************************************************************************************************************************/
/***************************************************
 *  
 ***************************************************
 * 
 */
#ifndef IS_BUZZER	
static void _setuptone(void){
		pinMode(BUZZER_PIN, OUTPUT);
		//PORTB = 0b00000000; // set all pins to LOW
		TCCR0A |= (1<<WGM01); // set timer mode to Fast PWM
		//TCCR0A |= (1<<COM0A0); // connect PWM pin to Channel A of Timer0
  		TCCR0A |= _BV(COM0B0); // connect PWM pin to Channel A of Timer0... PB1 ?
}
#endif
/***************************************************
 *  
 ***************************************************
 * 
 */
#ifndef IS_BUZZER		
static void _tone(uint8_t octave, uint8_t note)
{
	uint32_t ret;
	note_t *val;
	ret = pgm_read_word_near((uint8_t *)&octaves + sizeof(octave_t) * octave + sizeof(note_t) * note);
	val = (note_t *)&ret;
	TCCR0B = (TCCR0B & ~((1<<CS02)|(1<<CS01)|(1<<CS00))) | val->N;
  	OCR0A = val->OCRxn - 1; // set the OCRnx
}
#endif

/***************************************************
 *  
 ***************************************************
 * 
 */
#ifndef IS_BUZZER	
static void stop(void)
{

	TCCR0B &= ~((1<<CS02)|(1<<CS01)|(1<<CS00)); // stop the timer
}

#endif

/*******************************************************************************************************************************
 *  Sleeping Functions
 *******************************************************************************************************************************/
/***************************************************
 *  
 ***************************************************
 * 
 */

long wdtCount=0;                       //how many 8-sec WDT periods we've slept for
bool keepSleeping=true;                   //flag to keep sleeping or not

//void goToSleep(long wdtLimit) {
void goToSleep(void) {
	led_status(2,2);
	ADCSRA &= ~(1<<ADEN);		// Disable the ADC converter

	ACSR |= _BV(ACD);                         //disable the analog comparator
    ADCSRA &= ~_BV(ADEN);                     //disable ADC
    set_sleep_mode(SLEEP_MODE_PWR_DOWN);
    sleep_enable();

	// prescale timer to 8s so we can measure current
	WDTCR |= (1<<WDP3 )|(0<<WDP2 )|(0<<WDP1)|(1<<WDP0); // 8s



	// Enable watchdog timer interrupts
	WDTCR |= (1<<WDTIE);
	sei(); // Enable global interrupts
	// Use the Power Down sleep mode
	set_sleep_mode(SLEEP_MODE_PWR_DOWN);

	// With sleep_mode() you select the sleep mode you like to enter.
	// With sleep_cpu() you enter the sleep mode you have selected by calling sleep_mode().


	sleep_mode();   // go to sleep and wait for interrupt...
	//sleep_cpu();

}

/***************************************************
 *  
 ***************************************************
 * 
 */

//enable the WDT for 8sec interrupt
void wdtEnable(void)
{
    wdt_reset();
    cli();
    MCUSR = 0x00;
    WDTCR |= _BV(WDCE) | _BV(WDE);

    //WDTCR = _BV(WDIE) | _BV(WDP3) | _BV(WDP0);    //8192ms  //////////////////////////////////////////FIX
    
    WDTCR = _BV(WDTIE) | _BV(WDP3) | _BV(WDP0);    //8192ms  //////////////////////////////////////////FIX
    //WDTCR = (1<<WDE) | (1<<WDP2) | (1<<WDP0);

    //WDTCR = (1<<WDTIE)|(1<<WDP3) |(1<<WDP0);

/*
WDTCR |= (1<<WDP3 )|(0<<WDP2 )|(0<<WDP1)|(1<<WDP0); // 8s
is setting the timers configuration and 8s is the max Other values are listed:

16MS   (0<<WDP3 )|(0<<WDP2 )|(0<<WDP1)|(0<<WDP0)
32MS   (0<<WDP3 )|(0<<WDP2 )|(0<<WDP1)|(1<<WDP0)
64MS   (0<<WDP3 )|(0<<WDP2 )|(1<<WDP1)|(0<<WDP0)
125MS  (0<<WDP3 )|(0<<WDP2 )|(1<<WDP1)|(1<<WDP0)
250MS  (0<<WDP3 )|(1<<WDP2 )|(0<<WDP1)|(0<<WDP0)
500MS  (0<<WDP3 )|(1<<WDP2 )|(0<<WDP1)|(1<<WDP0)
1S     (0<<WDP3 )|(1<<WDP2 )|(1<<WDP1)|(0<<WDP0)
2S     (0<<WDP3 )|(1<<WDP2 )|(1<<WDP1)|(1<<WDP0)
4S     (1<<WDP3 )|(0<<WDP2 )|(0<<WDP1)|(0<<WDP0)
8S     (1<<WDP3 )|(0<<WDP2 )|(0<<WDP1)|(1<<WDP0)*/


    
    sei();
}

/***************************************************
 *  
 ***************************************************
 * 
 */

//disable the WDT
void wdtDisable(void)
{
    wdt_reset();
    cli();
    MCUSR = 0x00;
    WDTCR |= _BV(WDCE) | _BV(WDE);
    WDTCR = 0x00;
    sei();
}


/***************************************************
 *  
 ***************************************************
 * 
 */

// wdtLimit = number of WDT periods to wake after
void goToSleep_new(long wdtLimit)
{
    led_status(2,2);
    wdtCount = 0;
    
   
    do {
        ACSR |= _BV(ACD);                         //disable the analog comparator
        ADCSRA &= ~_BV(ADEN);                     //disable ADC
        set_sleep_mode(SLEEP_MODE_PWR_DOWN);
        sleep_enable();
        
        wdtEnable();              //start the WDT
        
        //turn off the brown-out detector.
        //must have an ATtiny45 or ATtiny85 rev C or later for software to be able to disable the BOD.
        //current while sleeping will be <0.5uA if BOD is disabled, <25uA if not.
        cli();
//        mcucr1 = MCUCR | _BV(BODS) | _BV(BODSE);  //turn off the brown-out detector
//        mcucr2 = mcucr1 & ~_BV(BODSE);
        MCUCR = mcucr1;
        MCUCR = mcucr2;
        sei();                         //ensure interrupts enabled so we can wake up again
        sleep_cpu();                   //go to sleep
                                       //----zzzz----zzzz----zzzz----zzzz
        cli();                         //wake up here, disable interrupts
        sleep_disable();
        wdtDisable();                  //don't need the watchdog while we're awake
        sei();                         //enable interrupts again (but INT0 is disabled above)

        if (++wdtCount < wdtLimit) {
            keepSleeping = true;
            // Do the thing we want
			_playtones();
        }
        else {
            keepSleeping = false;
        }
    } while (keepSleeping);
    
    //msWakeUp = millis();
}











/*******************************************************************************************************************************
 *  Random Number Generator that probably doesn't work cunt
 *******************************************************************************************************************************/
long countSleep=0;
long countSleepLimit=0;


/***************************************************
 * Random Number Generator 
 ***************************************************
 * 
 */

//#define USE_RANDOM_SEED

#ifdef    USE_RANDOM_SEED
#define    RANDOM_SEED_ADDRESS    0x00
#endif    /* !USE_RANDOM_SEED */

static uint16_t random_number = 0;
static uint16_t lfsr16_next(uint16_t n) {
    return (n >> 0x01U) ^ (-(n & 0x01U) & 0xB400U);    
}

void random_init(uint16_t seed) {
#ifdef USE_RANDOM_SEED
    random_number = lfsr16_next(eeprom_read_word((uint16_t *)RANDOM_SEED_ADDRESS) ^ seed);
    eeprom_write_word((uint16_t *)0, random_number);
#else
    random_number = seed;
#endif    /* !USE_RANDOM_SEED */
}

uint16_t _random( uint16_t _min, uint16_t _max) {
	uint16_t _return=0;
guessagain:
//	random_number = lfsr16_next(random_number);

	//remainder = dividend % divisor;
	// so lets make it 9, that way the remainder is 0
	uint16_t _modulus = (_max - _min);


	//_return =  random_number % (_max - _min);

	_return =   lfsr16_next(random_number);
	_return =   _return % _modulus;
	_return += _min;

	if (_return < _min) {
		led_blink(LED_RED,4);
		goto guessagain;
	}
	if (_return > _max){
		led_blink(LED_RED,8);
		goto guessagain;
	}

	return _return;
}

/*******************************************************************************************************************************
 *  Random number generator based I think on fuck.. i forget
 *******************************************************************************************************************************/
uint16_t _randomsystem( uint16_t _min, uint16_t _max) {
	uint16_t _modulus = (_max - _min);
	uint16_t _number = rand();					// I assume this makes it postiive??

	if (_number < 0) {		// lets call this out as an error
		led_blink(LED_RED,4);
		led_blink(LED_RED,4);
		_number = 0 - _number;	// make it positive
	}
	_number =   _number % _modulus;			// we only want the remainder
	_number += _min;						// we add the minimum number to it

	//check_random(_number);					// we check its within the limit
	return _number;
}


//Discard adc interrupt
EMPTY_INTERRUPT(ADC_vect)

#define ISR_BLANK

#ifdef ISR_BLANK
ISR(WDT_vect) {}  
#else
/*******************************************************************************************************************************
 *  ISR   ISR   ISR   ISR   ISR   ISR   ISR   ISR   ISR   ISR   ISR   ISR   ISR   ISR   ISR   ISR   ISR   ISR   ISR   ISR   ISR 
 *******************************************************************************************************************************/
// fucks knows why i need this???
ISR(WDT_vect) {
	led_status(3,1);

	led_blink(LED_GREEN,countSleep);

	countSleep++;


	if ((countSleep < countSleepLimit) ) {
		led_status(3,2);
		sei();			//ensure interrupts enabled so we can wake up again
		sleep_mode();	//wake up here, disable interrupts
		cli();			//wake up here, disable interrupts


	} else {
		led_status(3,3);
		if (countSleepLimit != 0) {		// if its not our first run
			_playtones();
		}

		countSleep = 0;	// reset countsleep
		countSleepLimit = 8;

//		countSleepLimit = _random(RANDOM_SLEEP_MIN, RANDOM_SLEEP_MAX + 1);
		
//		countSleepLimit = random(RANDOM_SLEEP_MIN, RANDOM_SLEEP_MAX + 1);		// this uses fuckloads

		// another way of calculating it...



		//countSleepLimit = RANDOM_SLEEP_MIN + rand()/(32727/(RANDOM_SLEEP_MAX - RANDOM_SLEEP_MIN));		// This works, uses a lot of flash

//		countSleepLimit = _randomsystem( RANDOM_SLEEP_MIN, RANDOM_SLEEP_MAX);
//#define RAND_MAX 

		check_random(countSleepLimit);


		

		// Now we add the factor to the sleep limit, so this shoudl be roughly 1 min 
//		countSleepLimit = SLEEP_FACTOR * countSleepLimit;

		// Do Our thing here
		

	}
}

#endif







/*******************************************************************************************************************************
 *  SETUP  SETUP  SETUP  SETUP  SETUP  SETUP  SETUP  SETUP  SETUP  SETUP  SETUP  SETUP  SETUP  SETUP  SETUP  SETUP  SETUP  SETUP
 *******************************************************************************************************************************/


void setup() {
	// setup random shit
	random_init(0xabcd); // initialize 16 bit seed

	pinMode(BUZZER_PIN, OUTPUT);

	led_setup();

	led_status(1,1);
	  
	_playtones();

	led_status(1,1);
}


/*******************************************************************************************************************************
 *  LOOP  LOOP  LOOP  LOOP  LOOP  LOOP  LOOP  LOOP  LOOP  LOOP  LOOP  LOOP  LOOP  LOOP  LOOP  LOOP  LOOP  LOOP  LOOP  LOOP  LOOP
 *******************************************************************************************************************************/

void loop() {

	led_status(2,1);
	//goToSleep();	// Should be in 8 second blocks

	goToSleep_new(200);

}